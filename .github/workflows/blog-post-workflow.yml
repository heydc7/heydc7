name: Latest content via JSON
on:
  schedule:
    - cron: "0 * * * *"   # hourly
  workflow_dispatch:
    inputs:
      section:
        description: "Which section to update?"
        required: true
        default: "all"
        type: choice
        options: [all, blog, writeups, projects]

permissions:
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Fetch index.json
        run: |
          FEED_URL="https://dhanraj.pages.dev/index.json"
          curl -sSL "$FEED_URL" -o /tmp/index.json

      - name: Build markdown blocks
        run: |
          # Normalize JSON: handle JSON Feed (.items) or PaperMod array
          jq 'if type=="object" and has("items") then .items else . end' /tmp/index.json > /tmp/items.json

          mklist () {
            # Generic list for blog/projects
            local path="$1" limit="$2"
            jq -r --arg path "$path" --argjson limit "$limit" '
              [ .[]
                | select((.permalink // .url) | tostring | contains($path))
                | {title: (.title // .name),
                   link:  (.permalink // .url)
                  }
              ]
              | .[0:$limit]
              | map("* [\(.title)](\(.link))")
              | join("\n")
            ' /tmp/items.json
          }

          mklist_writeups () {
            # WRITEUPS: keep feed order (latest-first), dedupe without sorting,
            # link to folder root, and replace "-" with space in the slug shown.
            local path="$1" limit="$2"
            jq -r --arg path "$path" --argjson limit "$limit" '
              reduce ( .[]
                | select((.permalink // .url) | tostring | contains($path))
                | { slug: ((.permalink // .url)
                            | capture(".*/writeups/(?<slug>[^/]+)/")
                            | .slug
                            | gsub("-"; " ")
                          ),
                    link: ((.permalink // .url)
                            | capture("(?<link>.*?/writeups/[^/]+)/")
                            | .link)
                  }
              ) as $item ( [];
                if any(.slug == $item.slug)
                then .
                else . + [$item]
                end
              )
              | .[0:$limit]
              | map("* [\(.slug)](\(.link)/)")
              | join("\n")
            ' /tmp/items.json
          }

          if [ "${{ github.event.inputs.section }}" = "all" ] || [ "${{ github.event.inputs.section }}" = "blog" ]; then
            mklist "/blog/" 20 > /tmp/blog.md
          fi
          if [ "${{ github.event.inputs.section }}" = "all" ] || [ "${{ github.event.inputs.section }}" = "writeups" ]; then
            mklist_writeups "/writeups/" 20 > /tmp/writeups.md
          fi
          if [ "${{ github.event.inputs.section }}" = "all" ] || [ "${{ github.event.inputs.section }}" = "projects" ]; then
            mklist "/projects/" 20 > /tmp/projects.md
          fi

      - name: Inject into README
        run: |
          inject () {
            local tag="$1" file="$2"
            local start="<!-- ${tag}:START -->"
            local end="<!-- ${tag}:END -->"

            if ! grep -qF "$start" README.md || ! grep -qF "$end" README.md; then
              echo "::warning::Markers for $tag not found in README.md; skipping."
              return 0
            fi

            awk -v s="$start" -v e="$end" -v f="$file" '
              $0==s { print; system("cat " f); skip=1; next }
              $0==e { skip=0 }
              !skip
            ' README.md > README.new
            mv README.new README.md
          }

          [ -f /tmp/blog.md ] && inject "BLOG" /tmp/blog.md
          [ -f /tmp/writeups.md ] && inject "WRITEUPS" /tmp/writeups.md
          [ -f /tmp/projects.md ] && inject "PROJECTS" /tmp/projects.md

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(readme): update ${{ github.event.inputs.section || 'all' }} from index.json"

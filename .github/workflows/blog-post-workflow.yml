name: Latest content via JSON
on:
  schedule:
    - cron: "0 * * * *"   # hourly
  workflow_dispatch:
    inputs:
      section:
        description: "Which section to update?"
        required: true
        default: "all"
        type: choice
        options: [all, blog, writeups, projects]

permissions:
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Fetch index.json
        run: |
          FEED_URL="https://dhanraj.pages.dev/index.json"
          curl -sSL "$FEED_URL" -o /tmp/index.json

      - name: Build markdown blocks
        run: |
          # Normalize JSON: JSON Feed (.items) or PaperMod array
          jq 'if type=="object" and has("items") then .items else . end' /tmp/index.json > /tmp/items.json

          mklist () {
            # Generic list for blog/projects
            local path="$1" limit="$2"
            jq -r --arg path "$path" --argjson limit "$limit" '
              [ .[]
                | select((.permalink // .url) | tostring | contains($path))
                | {title: (.title // .name),
                   link:  (.permalink // .url)
                  }
              ]
              | .[0:$limit]
              | map("* [\(.title)](\(.link))")
              | join("\n")
            ' /tmp/items.json
          }

          mklist_writeups () {
            # Keep feed order (latest-first), dedupe without sorting,
            # show slug with "-" â†’ " ", link to folder root.
            local path="$1" limit="$2"
            jq -r --arg path "$path" --argjson limit "$limit" '
              reduce ( .[]
                | select((.permalink // .url) | tostring | contains($path))
                | { slug: ((.permalink // .url)
                            | capture(".*/writeups/(?<slug>[^/]+)/")
                            | .slug
                            | gsub("-"; " ")
                          ),
                    link: ((.permalink // .url)
                            | capture("(?<link>.*?/writeups/[^/]+)")
                            | .link)
                  }
              ) as $item ( [];
                if (map(.slug) | index($item.slug)) then . else . + [$item] end
              )
              | .[0:$limit]
              | map("* [\(.slug)](\(.link)/)")
              | join("\n")
            ' /tmp/items.json
          }

          if [ "${{ github.event.inputs.section }}" = "all" ] || [ "${{ github.event.inputs.section }}" = "blog" ]; then
            mklist "/blog/" 20 > /tmp/blog.md
          fi
          if [ "${{ github.event.inputs.section }}" = "all" ] || [ "${{ github.event.inputs.section }}" = "writeups" ]; then
            mklist_writeups "/writeups/" 20 > /tmp/writeups.md
          fi
          if [ "${{ github.event.inputs.section }}" = "all" ] || [ "${{ github.event.inputs.section }}" = "projects" ]; then
            mklist "/projects/" 20 > /tmp/projects.md
          fi

      - name: Inject into README (safe)
        run: |
          python3 - <<'PY'
          import os, re, pathlib, sys

          def inject(tag: str, tmp_path: str):
            p = pathlib.Path("README.md")
            if not p.exists():
              print("::error::README.md not found")
              sys.exit(1)

            if not os.path.exists(tmp_path):
              return  # nothing to inject for this tag

            start = f"<!-- {tag}:START -->"
            end   = f"<!-- {tag}:END -->"

            text = p.read_text(encoding="utf-8")
            if start not in text or end not in text:
              print(f"::warning::Markers for {tag} not found in README.md; skipping.")
              return

            block = pathlib.Path(tmp_path).read_text(encoding="utf-8").strip()
            pattern = re.compile(re.escape(start) + r".*?" + re.escape(end), re.S)
            new_text = pattern.sub(start + "\n" + block + "\n" + end, text)
            p.write_text(new_text, encoding="utf-8")

          inject("BLOG", "/tmp/blog.md")
          inject("WRITEUPS", "/tmp/writeups.md")
          inject("PROJECTS", "/tmp/projects.md")
          PY

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(readme): update ${{ github.event.inputs.section || 'all' }} from index.json"
